# NeuroCrew Lab — архитектура (MVP)

## Общее описание
NeuroCrew Lab реализует паттерн **Puppet Master**: один бот-слушатель управляет несколькими ботами-актёрами, за которыми стоят AI-агенты (все через официальные CLI). Вся координация происходит в одном Telegram-чате, состояние хранится на диске. Технологический стек минимален: Python/asyncio, `python-telegram-bot`, subprocess-коннекторы для CLI и JSON-файлы в `data/`.

```
Пользователь → Telegram-группа → Listener Bot → NeuroCrew Core → Цепочка ролей
                                                   ↓
                                ACP: OpenCode/Qwen/Gemini, headless CLI: Codex/Claude
                                                   ↓
                                 Actor Bots → Telegram-группа
```

## Ответственность компонентов
- **main.py**  
  Настраивает логирование, проверяет доступность Telegram API, загружает роли и запускает `telegram_bot.TelegramBot` внутри asyncio.
- **telegram_bot.py**  
  Реализует listener-бота: фильтрует чаты, обрабатывает команды, стримит ответы ролей и пересылает их через соответствующих бот-актёров.
- **ncrew.py (NeuroCrewLab)**  
  Сердце системы: ведёт указатели ролей на чат, создаёт/переиспользует коннекторы, реализует ретраи и выдаёт ответы генератором для `TelegramBot`.
- **connectors/**  
  - `base.py` — общий интерфейс запуска/выполнения/завершения CLI-процессов.  
  - `opencode_acp_connector.py`, `qwen_acp_connector.py`, `gemini_acp_connector.py` — ACP-handshake, управление subprocess и потоками вывода.  
  - `codex_cli_connector.py` — headless `codex exec --json`.  
  - `claude_cli_connector.py` — headless `claude -p --output-format stream-json`.
- **storage/file_storage.py**  
  Асинхронно сохраняет историю в `data/conversations/chat_{id}.json`, добавляет метаданные и бэкапит повреждённые файлы.
- **config.py + roles/agents.yaml**  
  Реестр ролей на dataclass, динамический поиск токенов в `.env`, хранение системных параметров.
- **web_server.py + templates/index.html**  
  Мини-панель на Flask с Basic Auth для редактирования ролей и токенов без правки YAML вручную.
- **utils/**  
  Логгеры с маскированием секретов, форматирование сообщений, валидаторы безопасности.

## Поток данных
1. **Вход** — Listener-бот получает сообщение, проверяет, что чат целевой, валидирует и логирует безопасный фрагмент.
2. **Хранение** — Сообщение добавляется в историю, счётчики метрик обновляются.
3. **Цикл ролей** — `NeuroCrewLab.handle_message` перебирает роли, пока все не вернут `.....` или пока не достигнут лимит ошибок. Для каждой роли:
   - Формируется промпт из новых сообщений.
   - Проверяется состояние коннектора (ACP или SDK), при необходимости он запускается/инициализируется.
   - Через ACP/SDK отправляется промпт, собирается ответ, логируется время.
   - Ответ сохраняется в истории.
4. **Выход** — Для каждого значимого ответа TelegramBot ищет токен актёра и отправляет форматированное сообщение (разбивая >4 000 символов). При отсутствии токена используется бот-слушатель.
5. **Завершение** — `/reset` или остановка вызывают `NeuroCrewLab.shutdown_role_sessions`, что закрывает subprocess и очищает индексы по чату.

## Вид со стороны эксплуатации
- **Runtime**: один процесс, один asyncio loop, последовательное выполнение ролей.  
- **Зависимости**: `requirements.txt` (Flask, telegram-bot), локально установленные CLI (`opencode`, `qwen`, `gemini`, `codex`, `claude`).  
- **Состояние**: локальная файловая система и `.env`, оба исключены из git.  
- **Скрипты**: `ncrew.sh` для подготовки окружения, `scripts/*.py` для проверок, `web_server.py` для ручного редактирования ролей.

## Ограничения и компромиссы
- **Один чат** — снижает риски и упрощает фильтрацию, но исключает мульти-тенантность.  
- **Файловое хранилище** — прозрачно, но длинные истории требуют ручного управления (смягчается `MAX_CONVERSATION_LENGTH`).  
- **Последовательные роли** — детерминированный порядок без динамической маршрутизации.  
- **Без хостинга авторизации** — минимальная поверхность безопасности, но ответственность за CLI/API-ключи лежит на операторе.  
- **Ограниченная наблюдаемость** — только логи и `/metrics`, что соответствует философии MVP «без мониторинга».
