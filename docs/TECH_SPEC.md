# NeuroCrew Lab — Техническое задание (MVP)

## Цель
Создать Telegram-ориентированную платформу, где несколько автономных AI-агентов (CLI через ACP и API через SDK) выполняют задачи по фиксированной цепочке ролей в одном целевом чате. MVP нацелен на детерминированную маршрутизацию ролей, безопасное хранение состояния и соответствие правилам Telegram. Никаких дашбордов, продвинутых метрик или автомасштабирования.

## Объём работ
- **В рамках MVP**: жизненный цикл listener-бота, загрузка ролей из `roles/agents.yaml`, файловое хранилище диалогов, последовательное выполнение ролей с ACP- и Headless CLI-коннекторами, рассылка ответов через бот-актеров, базовые команды (`/start`, `/help`, `/reset`, `/status`, `/agents`, `/next`, `/about`, `/metrics`), минимальный веб-интерфейс (`app/interfaces/web_server.py`) для редактирования ролей и токенов.
- **Вне рамок**: поддержка нескольких чатов, real-time аналитика, автоматическое масштабирование, хранение API-ключей внутри проекта, отчётность/биллинг, сложные панели мониторинга.

## Контекст и предположения
- Операторы заранее создают N+1 Telegram-ботов (слушатель + актёры) и прописывают токены в `.env`.
- CLI-агенты (OpenCode, Qwen, Gemini и др.) устанавливаются и аутентифицируются пользователем вне NeuroCrew; Headless CLI агенты (Codex, Claude) используют свои CLI инструменты, которые должны быть авторизованы пользователем. API-ключи в проекте не хранятся.
- Работает только один групповой чат (`TARGET_CHAT_ID`), все остальные проигнорированы.
- Среда Linux/macOS, Python 3.10+, Node.js/Go для CLI, доступ на запись в `./data`.
- Веб-панель защищена Basic Auth (`WEB_ADMIN_USER/PASS`) и предназначена лишь для локального администрирования.

## Функциональные требования
1. **Приём сообщений**  
   - Listener-бот отбрасывает сообщения не из целевого чата.  
   - Текст проходит проверку `utils.security` и сохраняется в историю.
2. **Маршрутизация ролей**  
   - При запуске загружаем роли, проверяем доступность CLI и токенов, отключаем некорректные роли и ведём round-robin-указатели на чат.
3. **Выполнение коннекторов**  
   - ACP-коннекторы (OpenCode/Qwen/Gemini) держат долгоживущие процессы; каждое выполнение переиспользует сессию `(чат, роль)` до сброса.  
   - Headless CLI-коннекторы (Codex/Claude) вызывают CLI команды (`codex exec`, `claude -p`), используя системную авторизацию.
   - При сбое делаем до двух повторов, затем возвращаем ошибку.
4. **Хранение диалогов**  
   - История лежит в `data/conversations/chat_{id}.json` с метаданными; длина ограничена `MAX_CONVERSATION_LENGTH` (по умолчанию 200 сообщений, при необходимости настраивается).
5. **Выход в Telegram**  
   - Ответы отправляются от имени соответствующего бот-актера, при его отсутствии — через бот-слушатель.  
   - Сообщения >4 000 символов разбиваются с индексацией частей.
6. **Команды и обслуживание**  
   - `/reset` очищает историю и закрывает коннекторы чата.  
   - `/status`, `/metrics`, `/agents`, `/next`, `/about` дают лёгкие диагностические данные.  
   - `app/interfaces/web_server.py` позволяет обновлять `roles/agents.yaml` и токены через форму с базовой авторизацией.

## Нефункциональные требования
- **Надёжность**: Graceful shutdown завершает все subprocess за ≤15 с; ретраи скрывают кратковременные сбои ACP/API.
- **Безопасность**: В логах нет токенов; входные данные санитизируются. `.env` и `data/` исключены из git, API-ключи не сохраняются в репозитории.
- **Производительность**: Среднее время ответа коннектора ≤5 с при обычной нагрузке; никаких параллельных воркеров кроме одного asyncio-цикла.
- **Наблюдаемость**: Только консоль/файловые логи + команда `/metrics`; отдельные системы мониторинга не требуются.

## Деплой и эксплуатация
- Распространение через `ncrew.sh`, который готовит `.venv`, устанавливает зависимости, проверяет наличие CLI и запускает `python main.py`.
- При необходимости запускается `python app/interfaces/web_server.py` (порт 8080) с Basic Auth.
- Перед подключением к боевому чату должны проходить `python scripts/validate_system.py` и `python scripts/validate_agents.py`.
- Резервное копирование — копия `data/`, `.env` и пользовательских ключей в окружении; дополнительных сервисов для MVP не требуется.
