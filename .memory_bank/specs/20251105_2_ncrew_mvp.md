### **Техническое Задание: MVP "NeuroCrew Lab" (Архитектура "Кукловод")**

**1. Цель MVP**

Переработать существующее приложение для реализации архитектуры "Оркестратор-Кукловод". Конечный продукт должен работать в групповом чате Telegram, где один главный бот ("Слушатель") читает все сообщения, а несколько ботов-агентов ("Актеры") отвечают по очереди от своего имени. Все ключевые параметры (токены ботов, ID чата) должны быть вынесены в конфигурацию.

**2. Ключевая Архитектура**

1.  **Пользователь** пишет сообщение в специально созданный **Групповой Чат**.
2.  Только один бот, **Главный Слушатель**, читает это сообщение.
3.  Он проверяет, что сообщение пришло из целевого чата (`TARGET_CHAT_ID`).
4.  **Слушатель** передает текст в ядро **`NeuroCrewLab`**.
5.  Ядро, как и прежде, управляет очередью и выбирает, какой агент должен ответить (например, `qwen`).
6.  Ядро вызывает соответствующий **коннектор**, который запускает CLI-процесс агента `qwen-code`.
7.  CLI-процесс возвращает текстовый ответ.
8.  Ядро возвращает этот ответ и имя ответившего агента (`'qwen'`) обратно в модуль `telegram_bot`.
9.  Модуль `telegram_bot` находит API-токен для `'qwen'`, создает временный клиент и отправляет ответ в **Групповой Чат** от имени бота **`@QwenCodeBot`**.

**3. Задачи по Компонентам**

#### **Задача 1: Расширение Конфигурации (`.env.example` и `config.py`)**

Это **первоочередная и самая важная задача**, так как она закладывает основу для всех остальных изменений.

**1.1. Модифицировать `.env.example`:**
Файл должен содержать следующие переменные:

```dotenv
# Главный бот, который слушает чат
MAIN_BOT_TOKEN=your_main_listener_bot_token_here

# ID группового чата, в котором работает система.
# Сообщения из других чатов должны игнорироваться.
TARGET_CHAT_ID=your_target_group_chat_id_here

# Токены для ботов-агентов (Актеров).
# Формат: "имя_агента:токен,другой_агент:токен"
# Имена агентов (qwen, gemini и т.д.) должны совпадать с AGENT_SEQUENCE в config.py
AGENT_TOKENS=qwen:token_for_qwen_bot,gemini:token_for_gemini_bot,claude:token_for_claude_bot

# --- Существующие переменные ---
QWEN_CLI_PATH=/usr/local/bin/qwen-code
GEMINI_CLI_PATH=/usr/local/bin/gemini-cli
# ... и так далее
```

**1.2. Обновить `config.py`:**
Класс `Config` должен загружать и парсить новые переменные.

```python
# config.py

class Config:
    # ... существующие переменные ...

    # Главный токен для прослушивания
    MAIN_BOT_TOKEN: str = os.getenv('MAIN_BOT_TOKEN', '')

    # ID целевого чата
    TARGET_CHAT_ID: int = int(os.getenv('TARGET_CHAT_ID', '0'))

    # Словарь токенов для агентов-актеров
    AGENT_TOKENS: Dict[str, str] = {}

    @classmethod
    def _load_agent_tokens(cls):
        """Парсит строку AGENT_TOKENS в словарь."""
        tokens_str = os.getenv('AGENT_TOKENS', '')
        if not tokens_str:
            return {}
        
        token_dict = {}
        pairs = tokens_str.split(',')
        for pair in pairs:
            if ':' in pair:
                name, token = pair.split(':', 1)
                token_dict[name.strip()] = token.strip()
        cls.AGENT_TOKENS = token_dict

    @classmethod
    def validate(cls):
        """Обновить валидацию для новых переменных."""
        if not cls.MAIN_BOT_TOKEN or cls.MAIN_BOT_TOKEN == 'your_main_listener_bot_token_here':
            raise ValueError("MAIN_BOT_TOKEN не сконфигурирован.")
        
        if cls.TARGET_CHAT_ID == 0:
            raise ValueError("TARGET_CHAT_ID не сконфигурирован.")

        if not cls.AGENT_TOKENS:
            # Можно сделать это предупреждением, а не ошибкой, если какие-то агенты могут работать без токенов.
            # Для MVP - это ошибка.
            raise ValueError("AGENT_TOKENS не сконфигурирован или имеет неверный формат.")
        
        # ... существующая валидация ...
        return True

# В конце файла нужно вызвать загрузку токенов
Config._load_agent_tokens()
```

---

#### **Задача 2: Рефакторинг Ядра (`ncrew.py`)**

Ядро больше не должно отвечать за форматирование финального сообщения. Его задача — вернуть "сырой" ответ и имя агента.

**2.1. Изменить возвращаемое значение метода `handle_message`:**
Метод должен возвращать не `List[str]`, а кортеж `(str, str)`, содержащий `(имя_агента, текст_ответа)`.

```python
# ncrew.py -> class NeuroCrewLab

async def handle_message(self, chat_id: int, user_text: str) -> (Optional[str], Optional[str]):
    """
    Возвращает (имя_агента, текст_ответа) или (None, сообщение_об_ошибке).
    """
    # ... (логика сохранения сообщения пользователя) ...

    agent_name = await self._get_next_agent(chat_id)
    if not agent_name:
        return (None, "❌ Error: No agents are available right now")

    # В _process_with_agent убрать форматирование
    raw_response = await self._process_with_agent(chat_id, agent_name)

    return (agent_name, raw_response)


async def _process_with_agent(self, chat_id: int, agent_name: str) -> str:
    # ... (существующая логика) ...
    
    # --- ВАЖНОЕ ИЗМЕНЕНИЕ ---
    # Убрать форматирование в конце, возвращать "сырой" ответ
    # Было: formatted_response = format_agent_response(agent_name, response)
    # Стало:
    return response 
```

---

#### **Задача 3: Рефакторинг Telegram Бота (`telegram_bot.py`)**

Это **основной объем работы**. Модуль должен быть переписан для реализации логики "Кукловода".

**3.1. Изменить инициализацию:**
*   `Application` создается с `MAIN_BOT_TOKEN`.
*   Словарь `AGENT_TOKENS` загружается и хранится в объекте `TelegramBot`.

**3.2. Изменить логику обработчиков (`handle_message`, `cmd_*`):**
*   **Проверка Chat ID:** В самом начале каждого обработчика добавить проверку:
    ```python
    if update.effective_chat.id != Config.TARGET_CHAT_ID:
        self.logger.warning(f"Сообщение из нецелевого чата {update.effective_chat.id} проигнорировано.")
        return
    ```
*   **Логика `handle_message`:**
    1.  Вызвать `self.ncrew.handle_message()`, чтобы получить `(agent_name, raw_response)`.
    2.  Если `agent_name` есть, найти его токен в `Config.AGENT_TOKENS`.
    3.  Если токен найден, отправить сообщение с его помощью.
    4.  Если `agent_name` равен `None`, значит произошла ошибка. Отправить `raw_response` (сообщение об ошибке) от имени **главного бота**.

**Пример реализации отправки от имени "Актера":**
```python
# telegram_bot.py -> class TelegramBot

async def handle_message(self, update: Update, context: CallbackContext):
    if update.effective_chat.id != Config.TARGET_CHAT_ID:
        return # Игнорировать сообщения не из целевого чата

    # ... (логика отображения "Processing...") ...
    
    agent_name, raw_response = await self.ncrew.handle_message(chat_id, user_text)

    if agent_name and raw_response:
        # Успешный ответ от агента
        agent_token = Config.AGENT_TOKENS.get(agent_name)
        if agent_token:
            # Форматируем ответ здесь
            formatted_response = format_agent_response(agent_name, raw_response)
            # Разбиваем на части, если нужно
            messages_to_send = split_long_message(formatted_response)
            
            # Отправляем от имени актера
            from telegram import Bot
            actor_bot = Bot(token=agent_token)
            for msg in messages_to_send:
                await actor_bot.send_message(chat_id=Config.TARGET_CHAT_ID, text=msg, parse_mode='Markdown')
        else:
            # Если токен не найден, отправить от главного бота с пометкой
            await update.message.reply_text(f"Ошибка: Токен для агента '{agent_name}' не найден. Ответ:\n{raw_response}")
    
    elif raw_response:
        # Если произошла ошибка внутри ncrew
        await update.message.reply_text(raw_response)
```

*   **Логика команд (`/status`, `/reset` и т.д.):** Ответы на команды должны отправляться от имени **главного бота** (`update.message.reply_text(...)`).

---

#### **Задача 4: Обновление Документации (`README.md`)**

Необходимо обновить `README.md`, чтобы четко описать новые переменные окружения и объяснить пользователю, как настроить систему с N+1 ботами и групповым чатом. Раздел `Prerequisites`, который уже есть в файле, — отличная основа. Его нужно дополнить описанием новых переменных в `.env`.

**4. Критерии Готовности MVP**

1.  Приложение успешно запускается с новыми переменными окружения (`MAIN_BOT_TOKEN`, `TARGET_CHAT_ID`, `AGENT_TOKENS`).
2.  Бот игнорирует личные сообщения и сообщения из любых других чатов, кроме указанного в `TARGET_CHAT_ID`.
3.  Сообщения от пользователя в целевом чате поочередно обрабатываются агентами из `AGENT_SEQUENCE`.
4.  Ответ от агента (например, `qwen`) публикуется в чате от имени соответствующего бота-актера (например, `@QwenCodeBot`).
5.  Команды (`/status`, `/reset`) обрабатываются и ответ на них приходит от главного бота-слушателя.
6.  Файл `README.md` содержит актуальные инструкции по настройке.