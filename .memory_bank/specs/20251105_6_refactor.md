### **Техническое Задание: Рефакторинг NeuroCrew Lab до Чистой Ролевой Архитектуры**

**1. Общая Цель**

Основная цель данного рефакторинга — устранить архитектурные несоответствия и стабилизировать систему, полностью переведя ее на **чистую ролевую архитектуру со stateful-коннекторами**. Текущая кодовая база является нестабильным гибридом двух подходов, что приводит к избыточности кода, усложнению логики и критическим ошибкам в работе и тестах.

**2. Ключевые Принципы Целевой Архитектуры**

После завершения рефакторинга система **ДОЛЖНА** соответствовать следующим принципам:

1.  **Единый Источник Правды:** Файл `roles/agents.yaml` является **единственным** источником для определения ролей, их команд вызова, системных промптов и последовательности.
2.  **Фиксированная Последовательность:** Последовательность вызова ролей **строго** определяется их порядком в файле `roles/agents.yaml`.
3.  **Чисто Stateful-Коннекторы:** Все коннекторы **должны** реализовывать исключительно stateful-интерфейс для управления долгоживущими процессами CLI. Stateless-логика должна быть полностью удалена.
4.  **Безопасность Состояния Ядра:** Ядро `NeuroCrewLab` должно оставаться stateless по отношению к отдельным запросам. Информация о текущей выполняемой роли должна передаваться как аргумент между методами.

---

### **3. Подробные Задачи по Компонентам**

#### **Задача 1: Рефакторинг и Упрощение Конфигурации (Приоритет: КРИТИЧЕСКИЙ)**

**Цель:** Устранить дублирование, конфликты и сделать `agents.yaml` единственным источником правды для ролей.

**Действия:**

1.  **Удалить файл `role_config.py`**.
    *   **Причина:** Его содержимое (классы `RoleConfig`, `RolesRegistry`) является неотъемлемой частью логики конфигурации и должно находиться в `config.py` для упрощения структуры проекта.
    *   **Действие:** Перенести классы `RoleConfig` и `RolesRegistry` в начало файла `config.py`.

2.  **Обновить `.env.example`:**
    *   **Причина:** Текущий формат `TELEGRAM_BOT_TOKENS` негибкий. Нужно перейти на именованные переменные.
    *   **Действие:** Заменить `TELEGRAM_BOT_TOKENS=...` на отдельные переменные для каждого бота. Имя переменной должно формироваться как `{telegram_bot_name}_TOKEN`.
        ```dotenv
        # .env.example (целевой вид)
        SOFTWAREDEVBOT_TOKEN=your_token_here
        CODEREVIEWERBOT_TOKEN=your_token_here
        # ... и так далее для всех ботов из agents.yaml
        ```

3.  **Рефакторинг `config.py`:**
    *   **Действие:** Перенести классы `RoleConfig` и `RolesRegistry` из удаленного `role_config.py`.
    *   **Действие:** **Полностью удалить** устаревшие переменные `AGENT_SEQUENCE` и `CLI_PATHS`.
    *   **Действие:** **Переписать `_load_telegram_bot_tokens`**. Новая логика должна быть динамической:
        1.  Метод вызывается *после* загрузки ролей (`load_roles`).
        2.  Он итерирует по списку `cls.ROLES`.
        3.  Для каждой роли `role` он берет `role.telegram_bot_name` (например, "SoftwareDevBot").
        4.  Формирует имя переменной окружения: `var_name = f"{role.telegram_bot_name.upper()}_TOKEN"`.
        5.  Читает токен: `token = os.getenv(var_name)`.
        6.  Если токен найден, сохраняет его: `cls.TELEGRAM_BOT_TOKENS[role.telegram_bot_name] = token`.
    *   **Действие:** Убедиться, что при запуске приложения сначала вызывается `Config.load_roles()`, а затем `Config._load_telegram_bot_tokens()`.

---

#### **Задача 2: Полный Рефакторинг Модуля Коннекторов (Приоритет: КРИТИЧЕСКИЙ)**

**Цель:** Привести все коннекторы к единому, чистому и корректно работающему stateful-интерфейсу.

**Действия:**

1.  **В файле `connectors/base.py`:**
    *   **Действие:** **Заменить** текущее содержимое класса `BaseConnector` на следующий **чистый stateful-интерфейс**. Это эталон.

    ```python
    # connectors/base.py - ЦЕЛЕВАЯ ВЕРСИЯ
    from abc import ABC, abstractmethod
    import asyncio
    from utils.logger import get_logger

    class BaseConnector(ABC):
        def __init__(self):
            self.process: asyncio.subprocess.Process | None = None
            self.logger = get_logger(f"{self.__class__.__name__}")

        @abstractmethod
        async def launch(self, command: str, system_prompt: str):
            """Запускает CLI-процесс и отправляет системный промпт."""
            pass

        @abstractmethod
        async def execute(self, delta_prompt: str) -> str:
            """Отправляет дельту диалога в запущенный процесс и возвращает ответ."""
            pass

        async def shutdown(self):
            """Корректно завершает CLI-процесс."""
            # ... (реализация из предыдущего ответа) ...

        def is_alive(self) -> bool:
            """Проверяет, активен ли CLI-процесс."""
            return self.process is not None and self.process.returncode is None

        async def _read_until_timeout(self, timeout: float = 2.0) -> str:
            """
            Надежно читает stdout до тех пор, пока не наступит таймаут, 
            сигнализируя о завершении ответа агента.
            """
            # ... (реализация из предыдущего ответа) ...
    ```

2.  **Для КАЖДОГО файла коннектора (`qwen_connector.py`, `claude_connector.py` и т.д.):**
    *   **Действие:** Унаследовать класс от **нового, чистого `BaseConnector`**.
    *   **Действие:** **Полностью удалить** все старые и некорректные методы: `format_context`, `parse_response`, `check_availability`, `execute_stateful_with_system_prompt`, а также старую реализацию `execute`.
    *   **Действие:** **Реализовать метод `launch(self, command: str, system_prompt: str)`:**
        *   Логика должна использовать `asyncio.create_subprocess_exec` для запуска `command`.
        *   Процесс должен быть сохранен в `self.process`.
        *   Сразу после запуска, в `stdin` процесса должен быть отправлен `system_prompt`.
    *   **Действие:** **Реализовать метод `execute(self, delta_prompt: str)`:**
        *   Логика должна отправлять `delta_prompt` в `stdin` **уже запущенного** `self.process`.
        *   Для чтения ответа из `stdout` **обязательно использовать** унаследованный хелпер `self._read_until_timeout()`. Это обеспечит надежное получение полного ответа.
    *   **Действие:** Добавить базовую реализацию для `opencode_connector.py` и `codex_connector.py`, если они отсутствуют.

---

#### **Задача 3: Рефакторинг Ядра Оркестратора (`ncrew.py`)**

**Цель:** Упростить ядро, убрать из него лишнее состояние и адаптировать под работу с чистыми stateful-коннекторами.

**Действия:**

1.  **В классе `NeuroCrewLab`:**
    *   **Действие:** **Переименовать:**
        *   `chat_agent_pointers` -> `chat_role_pointers`
        *   `_get_next_agent` -> `_get_next_role`
        *   `_process_with_agent` -> `_process_with_role`
    *   **Действие:** Изменить `handle_message`, чтобы он возвращал кортеж `(RoleConfig, str)`, содержащий объект роли и "сырой" ответ.
    *   **Действие:** **Изменить `_process_with_role`:**
        *   **Удалить** все `hasattr` проверки и `if/else` ветки для stateful/stateless.
        *   Метод должен **безальтернативно** получать коннектор через `_get_or_create_role_connector`, вызывать `launch()` (если процесс не запущен) и затем `execute(delta_prompt)`.
    *   **Действие:** **Переименовать `self.role_sessions`** в `self.connector_sessions`, чтобы было понятнее, что там хранятся инстансы коннекторов.
    *   **Действие:** **Удалить** закомментированный/устаревший метод `continue_conversation`.

---

#### **Задача 4: Финальные Исправления**

1.  **В файле `main.py`:**
    *   **Действие:** Обновить логику стартового логирования: выводить информацию о загруженных **ролях** из `Config`, а не устаревшие данные.
2.  **В файле `telegram_bot.py`:**
    *   **Действие:** Убедиться, что `handle_message` корректно принимает `(RoleConfig, str)` от `ncrew.py`.
    *   **Действие:** Для отправки ответа должен использоваться `role_config.telegram_bot_name` для поиска токена в `Config.TELEGRAM_BOT_TOKENS`.
3.  **Удалить устаревшие файлы:**
    *   `role_config.py`
    *   `ROLE_ARCHITECTURE.md`
    *   `STATEFUL_CONNECTORS.md`

**4. Критерии Готовности (Definition of Done)**

1.  Все stateless-методы и fallback-логика полностью удалены из коннекторов и `ncrew.py`.
2.  Система успешно запускается и работает, используя **только** `roles/agents.yaml` для конфигурации ролей и последовательности.
3.  При обработке сообщений для каждой роли создается и переиспользуется **один** долгоживущий процесс CLI-агента.
4.  Конфигурация токенов полностью динамическая и зависит от `telegram_bot_name` в `agents.yaml`.
5.  Все существующие тесты (`tests/`) адаптированы под новую архитектуру и успешно проходят.
6.  Код стал чище, проще для понимания и не содержит "гибридной" логики.